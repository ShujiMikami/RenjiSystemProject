2018/11/3
  -ネット環境用に, RJ45とWifi両方装備がいい
  -ネットでのリモート見守りは, サーバーが必要. 利用料を取る方法がいい
  -ネット接続機能のアクティベートに, 会員登録が必要にし, 正しいID, Passを発行し, 入力が認められた時のみアクティベートする
  -ID, Passの使い回しを防ぐため, サーバー側で, 何台使用可能かをパラメータとしてもち, アクティベート済みの台数を管理する
  -同様の理由で, 初回接続時にはデバイス側でもID, Passをサーバーに確認する
  -Wifiや, ネットの接続設定は, PC, スマホをUSBで接続して専用アプリで行うこととし, 専用アプリのアドレスや, サイトアドレスを, QRコードとして筐体に印刷する
  -ESP-WROOM02の駆動用のマイコンと, ESP-WROOMという構成でいく
  -電源は, スマホ充電器のやつからUSB給電とする
  -RaspberryPiでの構成はだめ. すぐ解析, 真似される
  -ESP-WROOMを別モジュール化し, オプションパーツとして売るというのもあり
  -無線式の温度計は, 完全電池交換不能とし, 買い替え需要を狙う

2018/11/5
  -電源は, やはりコンセントからの給電. じゃないとライトが光らせられない

2018/11/7
  要求をSysMLで用意しよう

2018/11/10
  基板は複数枚構造としてよい.
  とりあえずelecrowは成功.
  Ethernetコントローラには, ENC28J60という28pinDIPタイプのコントローラがよさそう, QFNもある

2018/12/13
  Ethernetはとりあえずよしとく. いったんWifiのみでいく. Arduinoで8266制御する

2019/1/31
  8266ではGPIOが足りない. GPIOエキスパンダが必要. とりあえずLPC1114でいく. 
  安価かつ, 分解が容易で, 軽いケージ構造を考えた. 図は手書きをあげとく
  Boxはやはり, コンセントでヒータ, UV, FANをさせる構造がよい. 基板側は大きめのTHにしておき, ケーブルでコネクタをつなぎ, 筐体に固定する. 
  主電源ソケットも, 基板側は大きめのTHにしておき, ケーブルでコネクタをつなぎ, 筐体に固定する. 
  主電源は, 8の字型のやつがよかろう
  ヒューズを各電源ラインごとに設ける. ヒータが一番消費が大きいし, 電源回路はせいぜい数100mAで十分
  デバッグ用UART端子は必要.
  ADCもGPIOエキスパンダとする. 
  電源用スイッチ用のTHを大きめに作る. 
  設定用のスイッチ類は, 子基盤にまとめ, フレキか, フラットケーブルでつなぐのがよい. こちらに, チャタリング対策を入れておく. 
  制御ボックスも, アクリルケースで囲む. 板同士は, ネジで固定する. 
  制御ボックスの底は, 厚めのアクリル板としておき, ネジ穴を切る. これに六角スペーサーをねじ込み, これに基板をねじ止めする. 
  アクリルの加工可否は, 問い合わせ済み. 

2019/2/8
  ESP-WROOM-02は, Arduinoで使用する限り, I2Cや, SPIでのスレーブ化に対応していないようだ. 
  従って, 8266をマスター, STMをスレーブとしたうえで, 以下のようなフローで動作させる. 
  [STM]メインタスクから, SPIタスクに命令を渡す
  [STM]SPIタスクでは, 未処理の命令がある場合, GPIOを立てる
  [ESP]GPIOが立っているのを検知したら, SPIでSTMに対し, 命令内容を読み込む. 
  [STM]命令内容を返し, GPIOをLowにする. 
  [STM]命令実行中フラグを立てる. フラグが立っている間は, 次の命令を受け取らず, キューに残す
  [ESP]命令を実行し, 結果を送信する. 
  [STM]結果を受け取り, 待ちフラグをオフにする

  ArduinoのSPIのtransferBytes関数は, 与えるバッファ, データ配列のサイズを, 必ず4の倍数バイトにしないといけない. 
  そのうえで, 必要な送信バイト数だけ指定すればいい. 

2019/2/21
  FreeRTOSのHeapは, CubeMXで設定すると, 最低限しか確保されていないので, 最大に引き上げておく必要がある.
2019/2/22
  WiFiMCUのFWでの, prevCountをすべての疑似タスクで共有してしまっているので, 正しい動作をしていない. prevCountの変数を, タスクごとに持たせるのがよさそう. 
  STMのSPIスレーブは, 必ず1バイト単位とし, スレーブ側から, 受信可能状態であったかどうかのフラグを返すようにする. 
  受信可能フラグが正常に受信されなかった場合は, ホスト側(ESPWROOM)がもう一度送信する. 
  パケットの中身は, STM側が管理する
2019/2/23
  SPIは高速なのでノンブロッキングが必要ない. 従って, ブロッキング関数のみ実装

2019/3/11
  いろいろと悩んだが, 結局のところ, UARTにするのが一番いいだろう. 
  対話式しかありえない

2019/3/12
  UARTのDMA受信については, カウント数を__HAL_DMA_GETCOUNTER関数と, UARTのRCVCMPLETEイベントをうまく使ってアプリケーション層でリングバッファに対応しながら, 
  キューに収めていく必要がありそう. 
2019/3/13
  UARTのDMA受信データをキューに収める構造において, 以下のパターンを考慮する必要がある. 
  1 データバッファ内でreadがDMAに対し周回遅れしていない場合
    以下の二つの場合が考えられ, 存在しているデータを順にQueueに格納していけばいい. 
    1-1 データバッファ内で, 最後に読んだポジションに対し, データが最後に書き込まれたポジションが後ろの場合
      この場合は, 特に何も気にすることなく, DMAのGetCounterの数値から, readしたポジションを引けば, データカウントが得られる. 
      この条件は, GetCounter > readPos かつ, UARTReceiveCplt = falseと同値
    1-2 データバッファ内で, 最後に読んだポジションに対し, データが最後に書き込まれたポジションが前の場合
      この場合は, DMAのGetCounterの数値と, readPosから, バッファ終端までの残量を足し算した結果がデータカウントとなる. 
      この条件は, GetCounter < readPos かつ, UARTReceiveCplt = trueと同値 
  2 データバッファ内で周回遅れしてしまった場合
    以下の二つの場合が想定されるが, いずれの場合も, バッファオーバーフローとして, 受信に関するパラメータをクリアすればいい
    2-1 readPosがDMAに対し, 1回だけ周回遅れし, DMAがバッファの終端にたどり着いていない場合
      この状態は, GetCounterが, readPosよりもバッファ内で後ろにあり, かつ, UARTReceiveCplt = trueのときで判別できる
    2-2 readPosがDMAに対し, 1回以上周回遅れし, さらにDMAがバッファの終了まで到達した場合
      この状態は, GetCounterとreadPosの関係に一切依存せず, UARTReceiveCplt が2回以上trueになっていることで判別できる
2019/3/25
  通信方式とりあえず以下のような感じで. 
  基本的に対話型
  [M->S]{0xA0, ByteCount, CommandCode, Parameters, Chksum}
  [S->M]{0xA1, ByteCount, CommandCode, Data, Chksum}
  スレーブ側は, A1受信をトリガーに, データの蓄積を開始, ByteCount受信完了段階で, バイト解析を行い, Chksumチェックをし, 
  通過すれば, 解析結果に応じた動作をする. 動作を開始するにあたって, ACKを返し, 作業を開始する.
  動作作業中も, ノンブロッキング処理とし, 作業中にコマンドが来た場合は, 
  [S->M]{0xA2, ByteCount, ErrorCode, Chksum}
  というフォーマットでエラーを返すようにする. 

2019/5/14
  Wifiが受信したHTTPなどのメッセージは, WifiMCUの中で処理したほうが良い. 

2019/5/16
  ESPとSTMのすみわけについて
    ESPWROOMで, 常にWiFiのメッセージを受け取り, FIFOにためておく. FIFOが空じゃない場合, ポートを立てる. 
    STM32では, スレッドで常にESPのピンを監視しており, ピンが立ったら, UART経由で, コマンド内容送信要求を送る. 
    ESPWROOMは, FIFOから取り出したコマンドをUARTで送信し, もし空になったらピンを下ろし, 空でないならピンを上げたままにする. 
    